{
  "hash": "f5600ebf458bb0cbe0bbff087784dcfb",
  "result": {
    "markdown": "---\ntitle: NFL Elo Code\ndate: '2023-08-30'\ndate-modified: '2023-08-31'\ncategories: ['Python', 'NFL', 'R']\ndescription: 'Implementing Elo with code.'\nexecute: \n  message: false\n  warning: false\n---\n\n\nContinuing from the previous post on calculating Elo, here is a quick implementation with code.\n\n\n\n\n\nImports are pretty standard.\n\n```python\nimport numpy as np\nimport pandas as pd\nfrom datetime import datetime\nimport pyarrow.dataset as ds\nimport matplotlib.pyplot as plt\nfrom sklearn.metrics import accuracy_score\n\nplt.style.use('ggplot')\n# scientific notation off\nnp.set_printoptions(suppress = True)\npd.set_option('display.max_columns', None)\npd.options.display.float_format = '{:.2f}'.format\n\nDATA_PATH = '../../Documents/nfl/data/pbp'\n# do not need all 366 columns\nDATA_COLS = ['game_id', 'season', 'home_team', 'away_team', 'season_type', 'week', 'game_date', 'home_score', 'away_score', 'result']\n\n# correct name changes\nreplace_dict = {\n    'SD': 'LAC',\n    'OAK': 'LV',\n    'STL': 'LA'\n}\n\ndataset = ds.dataset(DATA_PATH, format = 'parquet')\ndf = (\n    dataset\n    .to_table(columns = DATA_COLS)\n    .to_pandas()\n    .drop_duplicates(subset = ['game_id'])\n    .reset_index(drop = True)\n    .replace({'home_team': replace_dict, 'away_team': replace_dict})\n    .assign(home_win = lambda x: np.where(x['home_score'] > x['away_score'], 1, 0))\n    )\n\n# elo functions\ndef calculate_expected_score(home_team_rating, away_team_rating, hfa=False):\n    if hfa:\n        home_team_rating += 40\n    return 1 / (1 + 10 ** ((home_team_rating - away_team_rating) / 400))\n\ndef calculate_new_rating(team_rating, observed_score, expected_score, k=20):\n    return team_rating + k * (observed_score - expected_score)\n```\n\nFirst we want to loop through each season to calculate the Elo ratings, then for the next season, regress the elo rating per the previous post. \n\n```python\nelo_ratings_dict = {}\n\n# Initialize ELO ratings for the first season\ninitial_elo_ratings = pd.DataFrame({\n    'team': sorted(df['home_team'].unique().tolist()),\n    'elo_rating': 1500,  # Starting ELO rating for all teams\n    'season': df['season'].min(),  # Set to the first season in your dataset\n    'week': 0\n})\n\nfor season in df['season'].unique():\n    df_season = df.query('season == @season').sort_values('game_date', ascending=True).reset_index(drop=True)\n    \n    elo_ratings = initial_elo_ratings.copy()  # Initialize ELO ratings for the current season\n    \n    if season > df['season'].min():\n        prev_season = season - 1\n        elo_ratings['elo_rating'] = elo_ratings_dict[(prev_season, df_season['week'].min())]['elo_rating'] * 2/3 + 1500 * 1/3\n    \n    for week in df_season['week'].unique():\n        df_week = df_season[df_season['week'] == week]\n\n        for game_i in range(df_week.shape[0]):\n            # Get data for the current game\n            home_team = df_week.iloc[game_i][\"home_team\"]\n            away_team = df_week.iloc[game_i][\"away_team\"]\n            home_score = df_week.iloc[game_i][\"home_win\"]\n            game_week = df_week.iloc[game_i][\"week\"]\n            game_season = df_week.iloc[game_i][\"season\"]\n\n            # Get the ratings for each team\n            home_rating = elo_ratings.query('team == @home_team').iloc[0]['elo_rating']\n            away_rating = elo_ratings.query('team == @away_team').iloc[0]['elo_rating']\n\n            # Calculate the expected score\n            expected_home_score = calculate_expected_score(home_rating, away_rating, hfa=False)\n            expected_away_score = 1 - expected_home_score\n\n            # Calculate the new ratings\n            new_home_rating = calculate_new_rating(home_rating, home_score, expected_home_score)\n            new_away_rating = calculate_new_rating(away_rating, 1 - home_score, expected_away_score)\n\n            # Update the ratings in the DataFrame for the current game\n            elo_ratings.loc[elo_ratings['team'] == home_team, 'elo_rating'] = new_home_rating\n            elo_ratings.loc[elo_ratings['team'] == away_team, 'elo_rating'] = new_away_rating\n\n            # Update the week and season for the teams\n            elo_ratings.loc[elo_ratings['team'] == home_team, 'season'] = game_season\n            elo_ratings.loc[elo_ratings['team'] == home_team, 'week'] = game_week\n            elo_ratings.loc[elo_ratings['team'] == away_team, 'season'] = game_season\n            elo_ratings.loc[elo_ratings['team'] == away_team, 'week'] = game_week\n\n            # to add the values to the original df\n            df.loc[(df['season'] == season) & (df['week'] == week) & (df['home_team'] == home_team), 'home_elo_rating'] = elo_ratings.query('team == @home_team')['elo_rating'].values[0]\n            df.loc[(df['season'] == season) & (df['week'] == week) & (df['away_team'] == away_team), 'away_elo_rating'] = elo_ratings.query('team == @away_team')['elo_rating'].values[0]\n\n        elo_ratings_dict[(season, week)] = elo_ratings.copy()\n    \n    initial_elo_ratings = elo_ratings.copy()\n```\n\nThen calculating the accuracy.\n\n```python\ndf = df.assign(\n    elo_pred = lambda x: calculate_expected_score(x['away_elo_rating'], x['home_elo_rating'], hfa=False),\n    elo_pred_team = lambda x: np.where(x['elo_pred'] > 0.5, x['home_team'], x['away_team']),\n    winning_team = lambda x: np.where(x['home_win'] == 1, x['home_team'], x['away_team'])\n)\n\ny = df['winning_team']\ny_hat = df['elo_pred_team']\n\nprint(f'Elo Accuracy: {accuracy_score(y, y_hat) * 100:.2f}%')\n```\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Elo Accuracy: 75.38%\"\n```\n:::\n:::\n\n\nThen visualise the accuracy by season.\n\n```python\naccuracy_df = (\n    df\n    .groupby('season')\n    .apply(lambda x: accuracy_score(x['winning_team'], x['elo_pred_team']) * 100)\n    .reset_index()\n    .rename(columns = {0: 'accuracy'})\n)\n\nyears = range(1999, 2022, 1)\nyear_lst = [datetime(year, 1, 1).strftime(\"'%y\") for year in years]\n\nplt.figure(figsize = (8, 4))\n\nplt.plot(accuracy_df['season'], accuracy_df['accuracy'], marker = 'o', color = '#2ca25f')\nplt.axhline(accuracy_df['accuracy'].mean(), color = 'black', linestyle = '--')\nplt.xticks(years, year_lst)\nplt.title('\\n Dotted Line = Average Accuracy')\nplt.suptitle('Elo Accuracy by Season')\nplt.xlabel('Season')\nplt.ylabel('Accuracy (%)')\nplt.savefig('elo_accuracy.png', dpi = 300, bbox_inches = 'tight')\nplt.show()\n```\n\n![Figure](elo_accuracy.png){fig-align=\"center\" width=\"1200\"}\n\nThis is why I like Elo so much. Only by using the two scores from each game you are able to achieve around $75\\%$ accuracy. Accounting for the home team can bring it close to $79\\%$ too. While there may be more complex methods that produce better results, I like to use Elo as an example that sometimes a simple model can achieve fairly good results.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}